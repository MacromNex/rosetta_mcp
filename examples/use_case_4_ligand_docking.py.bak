#!/usr/bin/env python3

"""
PyRosetta Ligand Docking - Use Case 4

Description: Performs high-resolution protein-ligand docking using the ligand-optimized
scoring function. This protocol performs small rigid-body perturbations, sidechain
packing, and minimization for ligand-protein complex refinement.

Based on: D120_Ligand_interface.py from PyRosetta demos
Category: Ligand docking
Environment: ./env

Requirements:
- PyRosetta installed and initialized
- Input PDB file with protein-ligand complex
- Optional: Ligand parameter file (.params)
"""

import os
import sys
import argparse
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def setup_pyrosetta():
    """Initialize PyRosetta with standard settings"""
    try:
        import pyrosetta
        import pyrosetta.rosetta as rosetta
        from pyrosetta import (
            init, Pose, pose_from_file,
            FoldTree, MoveMap, PyJobDistributor
        )
        from pyrosetta.rosetta import core, protocols

        # Initialize PyRosetta with constant seed for reproducibility
        init(extra_options="-constant_seed")
        logger.info("PyRosetta initialized successfully")
        return True, pyrosetta, rosetta
    except ImportError as e:
        logger.error(f"PyRosetta import failed: {e}")
        logger.error("Please install PyRosetta: conda install -c rosettacommons pyrosetta")
        return False, None, None

def setup_ligand_fold_tree(pose, ligand_chain, protein_chain):
    """
    Set up fold tree for ligand docking

    Args:
        pose: PyRosetta pose
        ligand_chain: Chain ID of the ligand
        protein_chain: Chain ID of the protein
    """
    # Find ligand and protein residues
    ligand_res = []
    protein_res = []

    for i in range(1, pose.total_residue() + 1):
        chain = pose.pdb_info().chain(i)
        if chain == ligand_chain:
            ligand_res.append(i)
        elif chain == protein_chain:
            protein_res.append(i)

    if not ligand_res:
        logger.error(f"No ligand residues found in chain {ligand_chain}")
        return False

    if not protein_res:
        logger.error(f"No protein residues found in chain {protein_chain}")
        return False

    # Create fold tree with jump to ligand
    ft = FoldTree()

    # Protein backbone
    if len(protein_res) > 1:
        ft.add_edge(protein_res[0], protein_res[-1], -1)

    # Jump from protein to ligand
    anchor_protein = protein_res[len(protein_res)//2]  # Middle of protein
    anchor_ligand = ligand_res[0]  # First ligand residue

    ft.add_edge(anchor_protein, anchor_ligand, 1)  # Jump

    # Ligand residues
    for i in range(len(ligand_res) - 1):
        ft.add_edge(ligand_res[i], ligand_res[i+1], -1)

    pose.fold_tree(ft)
    logger.info(f"Ligand fold tree set up: Protein chain {protein_chain}, Ligand chain {ligand_chain}")
    logger.info(f"Jump from protein res {anchor_protein} to ligand res {anchor_ligand}")

    return True

def ligand_docking(pdb_file, ligand_chain="B", protein_chain="A", output_prefix="ligand_dock",
                  num_trajectories=20, params_file=None, use_pymol=False):
    """
    Perform ligand docking using PyRosetta

    Args:
        pdb_file (str): Input PDB file path with protein-ligand complex
        ligand_chain (str): Chain ID of the ligand
        protein_chain (str): Chain ID of the protein
        output_prefix (str): Prefix for output files
        num_trajectories (int): Number of docking trajectories
        params_file (str): Ligand parameter file (optional)
        use_pymol (bool): Enable PyMOL visualization

    Returns:
        bool: Success status
    """
    success, pyrosetta, rosetta = setup_pyrosetta()
    if not success:
        return False

    try:
        from pyrosetta import (
            Pose, pose_from_file,
            FoldTree, MoveMap, PyJobDistributor
        )
        from pyrosetta.rosetta import core, protocols

        # 1. Load ligand parameters if provided
        if params_file and os.path.exists(params_file):
            logger.info(f"Loading ligand parameters from {params_file}")
            core.chemical.ChemicalManager.get_instance().read_files_for_base_residue_types(params_file)

        # 2. Load the input structure
        logger.info(f"Loading protein-ligand complex from {pdb_file}")
        pose = pose_from_file(pdb_file)

        # 3. Set up ligand scoring function
        scorefxn = core.scoring.ScoreFunctionFactory.create_score_function("ligand")
        logger.info(f"Original score: {scorefxn(pose):.2f}")

        # 4. Set up fold tree for ligand docking
        if not setup_ligand_fold_tree(pose, ligand_chain, protein_chain):
            return False

        # 5. Identify ligand residues
        ligand_residues = []
        for i in range(1, pose.total_residue() + 1):
            if pose.pdb_info().chain(i) == ligand_chain:
                ligand_residues.append(i)

        if not ligand_residues:
            logger.error(f"No ligand residues found in chain {ligand_chain}")
            return False

        ligand_jump = 1  # Assuming first jump is to ligand

        # 6. Set up move map
        movemap = MoveMap()
        movemap.set_jump(ligand_jump, True)  # Allow ligand to move
        movemap.set_chi(True)  # Allow all sidechain movement

        # Allow ligand backbone movement if multi-residue
        for res in ligand_residues:
            movemap.set_bb(res, True)

        # 7. Set up ligand perturbation movers
        # Small rigid body perturbations
        perturb_mover = protocols.rigid.RigidBodyPerturbMover(ligand_jump, 0.5, 3.0)  # 0.5Å, 3°

        # Large rigid body perturbations for initial randomization
        randomize_mover = protocols.rigid.RigidBodyRandomizeMover(pose, ligand_jump, protocols.rigid.partner_downstream)

        # 8. Set up minimization
        min_mover = protocols.simple_moves.MinMover()
        min_mover.movemap(movemap)
        min_mover.score_function(scorefxn)

        # 9. Set up rotamer packing
        task_factory = core.pack.task.TaskFactory()

        # Restrict packing to interface residues
        interface_calc = protocols.analysis.InterfaceAnalyzerMover()
        interface_calc.set_interface(f"{protein_chain}_{ligand_chain}")

        packer = protocols.simple_moves.PackRotamersMover(scorefxn)
        packer.task_factory(task_factory)

        # 10. Set up Monte Carlo
        mc = protocols.moves.MonteCarlo(pose, scorefxn, 2.0)  # kT = 2.0

        # 11. Create docking sequence
        dock_sequence = protocols.moves.SequenceMover()
        dock_sequence.add_mover(perturb_mover)
        dock_sequence.add_mover(packer)
        dock_sequence.add_mover(min_mover)

        # Trial mover with Monte Carlo
        trial_mover = protocols.moves.TrialMover(dock_sequence, mc)

        # Repeat mover
        repeat_mover = protocols.moves.RepeatMover(trial_mover, 50)  # 50 cycles per trajectory

        # 12. Set up job distributor
        job_distributor = PyJobDistributor(output_prefix, num_trajectories, scorefxn)

        # 13. Run ligand docking trajectories
        logger.info(f"Starting {num_trajectories} ligand docking trajectories")
        scores = []
        interface_scores = []

        while not job_distributor.job_complete:
            # Reset pose for new trajectory
            test_pose = Pose()
            test_pose.assign(pose)

            # Reset Monte Carlo
            mc.reset(test_pose)

            # Set pose name
            job_name = job_distributor.output_name()
            test_pose.pdb_info().name(job_name)

            try:
                # 1. Initial randomization
                randomize_mover.apply(test_pose)

                # 2. Run docking protocol
                repeat_mover.apply(test_pose)

                # 3. Final minimization
                min_mover.apply(test_pose)

                # 4. Calculate scores
                final_score = scorefxn(test_pose)

                # Calculate interface score using InterfaceAnalyzerMover
                try:
                    interface_analyzer = protocols.analysis.InterfaceAnalyzerMover()
                    interface_analyzer.set_interface(f"{protein_chain}_{ligand_chain}")
                    interface_analyzer.apply(test_pose)
                    interface_score = interface_analyzer.get_interface_dG()
                except:
                    interface_score = final_score  # Fallback

                scores.append(final_score)
                interface_scores.append(interface_score)

                logger.info(f"Trajectory {len(scores)}: Score = {final_score:.2f}, Interface = {interface_score:.2f}")

                # Output structure
                job_distributor.output_decoy(test_pose)

            except Exception as e:
                logger.warning(f"Trajectory {len(scores)+1} failed: {e}")
                # Output original pose as fallback
                job_distributor.output_decoy(pose)

        # 14. Summary
        if scores:
            best_score_idx = scores.index(min(scores))
            best_score = scores[best_score_idx]
            best_interface = interface_scores[best_score_idx]

            logger.info("Ligand docking completed successfully!")
            logger.info(f"Best total score: {best_score:.2f}")
            logger.info(f"Best interface score: {best_interface:.2f}")
            logger.info(f"Average total score: {sum(scores)/len(scores):.2f}")
            logger.info(f"Average interface score: {sum(interface_scores)/len(interface_scores):.2f}")

        return True

    except Exception as e:
        logger.error(f"Error during ligand docking: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Ligand Docking using PyRosetta')
    parser.add_argument('--input', '-i', required=True, help='Input PDB file with protein-ligand complex')
    parser.add_argument('--ligand_chain', '-l', default='B', help='Ligand chain ID (default: B)')
    parser.add_argument('--protein_chain', '-p', default='A', help='Protein chain ID (default: A)')
    parser.add_argument('--output', '-o', default='ligand_dock', help='Output prefix (default: ligand_dock)')
    parser.add_argument('--trajectories', '-n', type=int, default=20, help='Number of trajectories (default: 20)')
    parser.add_argument('--params', help='Ligand parameter file (.params)')
    parser.add_argument('--pymol', action='store_true', help='Enable PyMOL visualization')
    parser.add_argument('--demo', action='store_true', help='Run with demo data')

    args = parser.parse_args()

    # Handle demo mode
    if args.demo:
        demo_pdb = os.path.join('examples', 'data', 'test_ligand.pdb')
        if not os.path.exists(demo_pdb):
            logger.warning(f"Demo file {demo_pdb} not found. Creating minimal demo structure...")
            # Create a simple protein-ligand demo PDB
            demo_content = """ATOM      1  N   ALA A   1      10.000  10.000  10.000  1.00 20.00           N
ATOM      2  CA  ALA A   1      11.000  10.000  10.000  1.00 20.00           C
ATOM      3  C   ALA A   1      11.500  11.000  10.000  1.00 20.00           C
ATOM      4  O   ALA A   1      11.500  12.000  10.000  1.00 20.00           O
TER
HETATM    5  C1  LIG B   1      15.000  10.000  10.000  1.00 20.00           C
HETATM    6  C2  LIG B   1      16.000  10.000  10.000  1.00 20.00           C
HETATM    7  O1  LIG B   1      17.000  10.000  10.000  1.00 20.00           O
TER
END
"""
            os.makedirs(os.path.dirname(demo_pdb), exist_ok=True)
            with open(demo_pdb, 'w') as f:
                f.write(demo_content)
        args.input = demo_pdb
        args.trajectories = 5  # Smaller for demo

    # Validate input file
    if not os.path.exists(args.input):
        logger.error(f"Input file {args.input} not found!")
        return 1

    # Run ligand docking
    logger.info("Starting ligand docking...")
    success = ligand_docking(
        pdb_file=args.input,
        ligand_chain=args.ligand_chain,
        protein_chain=args.protein_chain,
        output_prefix=args.output,
        num_trajectories=args.trajectories,
        params_file=args.params,
        use_pymol=args.pymol
    )

    if success:
        logger.info("Ligand docking completed successfully!")
        return 0
    else:
        logger.error("Ligand docking failed!")
        return 1

if __name__ == "__main__":
    sys.exit(main())